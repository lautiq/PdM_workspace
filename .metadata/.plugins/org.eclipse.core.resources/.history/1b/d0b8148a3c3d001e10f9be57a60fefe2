/**
  ******************************************************************************
  * @file           : APIDebounce.c
  * @brief          : Implementación de funciones para el manejo de anti-rebote
  *                   utilizando una MEF (Máquina de Estados Finitos) y la BSP
  *                   (Board Support Package) para la lectura del botón.
  *
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) [13-07-2023] [Lauta]
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */


/* Includes ------------------------------------------------------------------*/
#include "API_debounce.h"
#include "API_delay.h"


Button buttons[] = {
	    {GPIOA, GPIO_PIN_0}, // BTN1
	    {GPIOA, GPIO_PIN_1}, // BTN2
	    {GPIOA, GPIO_PIN_2}  // BTN3
};


/* Private defines -----------------------------------------------------------*/
#define DEBOUNCE_TIME_MS 40



/* Private variables ---------------------------------------------------------*/
static debounceState_t currentState;
static delay_t debounceDelay;




/* Public functions ----------------------------------------------------------*/
/**
 * @brief  Inicializa la MEF de anti-rebote.
 *
 * @note   Esta función inicializa la Máquina de Estados Finitos (MEF) utilizada
 *         para el anti-rebote del botón. Debe ser llamada al inicio del programa
 *         antes de utilizar las funciones de anti-rebote.
 *
 * @note   Si el botón está presionado al momento de iniciar el programa, se activará
 *         la función de error y el LED incorporado se encenderá. El programa quedará
 *         bloqueado en este estado hasta que se reinicie.
 *
 * @retval None
 */
void debounceFSM_init()
{
	GPIO_PinState buttonState = BSP_PB_GetState(BUTTON_USER);
	if(buttonState == GPIO_PIN_RESET)
	{
		error_Handler();
	}

	currentState = BUTTON_UP;
	delayInit(&debounceDelay, DEBOUNCE_TIME_MS);
}

void readButtons()
{
    GPIO_PinState BTN1_PinState = BSP_PB_GetState(BTN1);
    GPIO_PinState BTN2_PinState = BSP_PB_GetState(BTN2);
    GPIO_PinState BTN3_PinState = BSP_PB_GetState(BTN3);

    if (BTN1_PinState == GPIO_PIN_SET)
    {
        BTN1_State = TRUE;
    }
    else
    {
        BTN1_State = FALSE;
    }

    if (BTN2_PinState == GPIO_PIN_SET)
    {
        BTN2_State = TRUE;
    }
    else
    {
        BTN2_State = FALSE;
    }

    if (BTN3_PinState == GPIO_PIN_SET)
    {
        BTN3_State = TRUE;
    }
    else
    {
        BTN3_State = FALSE;
    }
}






/* Error handling function ----------------------------------------------------*/
/**
 * @brief  Función de manejo de errores.
 * @note   Esta función es llamada si se detecta un error durante la inicialización
 *         de la MEF. Se recomienda agregar aquí el código de manejo de errores
 *         adecuado para el proyecto.
 * @retval None
 */
void error_Handler()
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
	BSP_LED_Toggle(LED_BUILTIN);
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}






